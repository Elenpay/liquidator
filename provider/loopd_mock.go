// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/lightninglabs/loop/looprpc (interfaces: SwapClientClient)
//
// Generated by this command:
//
//	mockgen -destination ./loopd_mock.go -package provider github.com/lightninglabs/loop/looprpc SwapClientClient
//

// Package provider is a generated GoMock package.
package provider

import (
	context "context"
	reflect "reflect"

	looprpc "github.com/lightninglabs/loop/looprpc"
	gomock "go.uber.org/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockSwapClientClient is a mock of SwapClientClient interface.
type MockSwapClientClient struct {
	ctrl     *gomock.Controller
	recorder *MockSwapClientClientMockRecorder
	isgomock struct{}
}

// MockSwapClientClientMockRecorder is the mock recorder for MockSwapClientClient.
type MockSwapClientClientMockRecorder struct {
	mock *MockSwapClientClient
}

// NewMockSwapClientClient creates a new mock instance.
func NewMockSwapClientClient(ctrl *gomock.Controller) *MockSwapClientClient {
	mock := &MockSwapClientClient{ctrl: ctrl}
	mock.recorder = &MockSwapClientClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSwapClientClient) EXPECT() *MockSwapClientClientMockRecorder {
	return m.recorder
}

// AbandonSwap mocks base method.
func (m *MockSwapClientClient) AbandonSwap(ctx context.Context, in *looprpc.AbandonSwapRequest, opts ...grpc.CallOption) (*looprpc.AbandonSwapResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AbandonSwap", varargs...)
	ret0, _ := ret[0].(*looprpc.AbandonSwapResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AbandonSwap indicates an expected call of AbandonSwap.
func (mr *MockSwapClientClientMockRecorder) AbandonSwap(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AbandonSwap", reflect.TypeOf((*MockSwapClientClient)(nil).AbandonSwap), varargs...)
}

// FetchL402Token mocks base method.
func (m *MockSwapClientClient) FetchL402Token(ctx context.Context, in *looprpc.FetchL402TokenRequest, opts ...grpc.CallOption) (*looprpc.FetchL402TokenResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FetchL402Token", varargs...)
	ret0, _ := ret[0].(*looprpc.FetchL402TokenResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchL402Token indicates an expected call of FetchL402Token.
func (mr *MockSwapClientClientMockRecorder) FetchL402Token(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchL402Token", reflect.TypeOf((*MockSwapClientClient)(nil).FetchL402Token), varargs...)
}

// GetInfo mocks base method.
func (m *MockSwapClientClient) GetInfo(ctx context.Context, in *looprpc.GetInfoRequest, opts ...grpc.CallOption) (*looprpc.GetInfoResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetInfo", varargs...)
	ret0, _ := ret[0].(*looprpc.GetInfoResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetInfo indicates an expected call of GetInfo.
func (mr *MockSwapClientClientMockRecorder) GetInfo(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInfo", reflect.TypeOf((*MockSwapClientClient)(nil).GetInfo), varargs...)
}

// GetL402Tokens mocks base method.
func (m *MockSwapClientClient) GetL402Tokens(ctx context.Context, in *looprpc.TokensRequest, opts ...grpc.CallOption) (*looprpc.TokensResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetL402Tokens", varargs...)
	ret0, _ := ret[0].(*looprpc.TokensResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetL402Tokens indicates an expected call of GetL402Tokens.
func (mr *MockSwapClientClientMockRecorder) GetL402Tokens(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetL402Tokens", reflect.TypeOf((*MockSwapClientClient)(nil).GetL402Tokens), varargs...)
}

// GetLiquidityParams mocks base method.
func (m *MockSwapClientClient) GetLiquidityParams(ctx context.Context, in *looprpc.GetLiquidityParamsRequest, opts ...grpc.CallOption) (*looprpc.LiquidityParameters, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetLiquidityParams", varargs...)
	ret0, _ := ret[0].(*looprpc.LiquidityParameters)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLiquidityParams indicates an expected call of GetLiquidityParams.
func (mr *MockSwapClientClientMockRecorder) GetLiquidityParams(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLiquidityParams", reflect.TypeOf((*MockSwapClientClient)(nil).GetLiquidityParams), varargs...)
}

// GetLoopInQuote mocks base method.
func (m *MockSwapClientClient) GetLoopInQuote(ctx context.Context, in *looprpc.QuoteRequest, opts ...grpc.CallOption) (*looprpc.InQuoteResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetLoopInQuote", varargs...)
	ret0, _ := ret[0].(*looprpc.InQuoteResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLoopInQuote indicates an expected call of GetLoopInQuote.
func (mr *MockSwapClientClientMockRecorder) GetLoopInQuote(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLoopInQuote", reflect.TypeOf((*MockSwapClientClient)(nil).GetLoopInQuote), varargs...)
}

// GetLoopInTerms mocks base method.
func (m *MockSwapClientClient) GetLoopInTerms(ctx context.Context, in *looprpc.TermsRequest, opts ...grpc.CallOption) (*looprpc.InTermsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetLoopInTerms", varargs...)
	ret0, _ := ret[0].(*looprpc.InTermsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLoopInTerms indicates an expected call of GetLoopInTerms.
func (mr *MockSwapClientClientMockRecorder) GetLoopInTerms(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLoopInTerms", reflect.TypeOf((*MockSwapClientClient)(nil).GetLoopInTerms), varargs...)
}

// GetLsatTokens mocks base method.
func (m *MockSwapClientClient) GetLsatTokens(ctx context.Context, in *looprpc.TokensRequest, opts ...grpc.CallOption) (*looprpc.TokensResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetLsatTokens", varargs...)
	ret0, _ := ret[0].(*looprpc.TokensResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLsatTokens indicates an expected call of GetLsatTokens.
func (mr *MockSwapClientClientMockRecorder) GetLsatTokens(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLsatTokens", reflect.TypeOf((*MockSwapClientClient)(nil).GetLsatTokens), varargs...)
}

// GetStaticAddressSummary mocks base method.
func (m *MockSwapClientClient) GetStaticAddressSummary(ctx context.Context, in *looprpc.StaticAddressSummaryRequest, opts ...grpc.CallOption) (*looprpc.StaticAddressSummaryResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetStaticAddressSummary", varargs...)
	ret0, _ := ret[0].(*looprpc.StaticAddressSummaryResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStaticAddressSummary indicates an expected call of GetStaticAddressSummary.
func (mr *MockSwapClientClientMockRecorder) GetStaticAddressSummary(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStaticAddressSummary", reflect.TypeOf((*MockSwapClientClient)(nil).GetStaticAddressSummary), varargs...)
}

// InstantOut mocks base method.
func (m *MockSwapClientClient) InstantOut(ctx context.Context, in *looprpc.InstantOutRequest, opts ...grpc.CallOption) (*looprpc.InstantOutResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InstantOut", varargs...)
	ret0, _ := ret[0].(*looprpc.InstantOutResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InstantOut indicates an expected call of InstantOut.
func (mr *MockSwapClientClientMockRecorder) InstantOut(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstantOut", reflect.TypeOf((*MockSwapClientClient)(nil).InstantOut), varargs...)
}

// InstantOutQuote mocks base method.
func (m *MockSwapClientClient) InstantOutQuote(ctx context.Context, in *looprpc.InstantOutQuoteRequest, opts ...grpc.CallOption) (*looprpc.InstantOutQuoteResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InstantOutQuote", varargs...)
	ret0, _ := ret[0].(*looprpc.InstantOutQuoteResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InstantOutQuote indicates an expected call of InstantOutQuote.
func (mr *MockSwapClientClientMockRecorder) InstantOutQuote(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstantOutQuote", reflect.TypeOf((*MockSwapClientClient)(nil).InstantOutQuote), varargs...)
}

// ListInstantOuts mocks base method.
func (m *MockSwapClientClient) ListInstantOuts(ctx context.Context, in *looprpc.ListInstantOutsRequest, opts ...grpc.CallOption) (*looprpc.ListInstantOutsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListInstantOuts", varargs...)
	ret0, _ := ret[0].(*looprpc.ListInstantOutsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListInstantOuts indicates an expected call of ListInstantOuts.
func (mr *MockSwapClientClientMockRecorder) ListInstantOuts(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListInstantOuts", reflect.TypeOf((*MockSwapClientClient)(nil).ListInstantOuts), varargs...)
}

// ListReservations mocks base method.
func (m *MockSwapClientClient) ListReservations(ctx context.Context, in *looprpc.ListReservationsRequest, opts ...grpc.CallOption) (*looprpc.ListReservationsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListReservations", varargs...)
	ret0, _ := ret[0].(*looprpc.ListReservationsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListReservations indicates an expected call of ListReservations.
func (mr *MockSwapClientClientMockRecorder) ListReservations(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListReservations", reflect.TypeOf((*MockSwapClientClient)(nil).ListReservations), varargs...)
}

// ListStaticAddressDeposits mocks base method.
func (m *MockSwapClientClient) ListStaticAddressDeposits(ctx context.Context, in *looprpc.ListStaticAddressDepositsRequest, opts ...grpc.CallOption) (*looprpc.ListStaticAddressDepositsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListStaticAddressDeposits", varargs...)
	ret0, _ := ret[0].(*looprpc.ListStaticAddressDepositsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListStaticAddressDeposits indicates an expected call of ListStaticAddressDeposits.
func (mr *MockSwapClientClientMockRecorder) ListStaticAddressDeposits(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListStaticAddressDeposits", reflect.TypeOf((*MockSwapClientClient)(nil).ListStaticAddressDeposits), varargs...)
}

// ListStaticAddressSwaps mocks base method.
func (m *MockSwapClientClient) ListStaticAddressSwaps(ctx context.Context, in *looprpc.ListStaticAddressSwapsRequest, opts ...grpc.CallOption) (*looprpc.ListStaticAddressSwapsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListStaticAddressSwaps", varargs...)
	ret0, _ := ret[0].(*looprpc.ListStaticAddressSwapsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListStaticAddressSwaps indicates an expected call of ListStaticAddressSwaps.
func (mr *MockSwapClientClientMockRecorder) ListStaticAddressSwaps(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListStaticAddressSwaps", reflect.TypeOf((*MockSwapClientClient)(nil).ListStaticAddressSwaps), varargs...)
}

// ListSwaps mocks base method.
func (m *MockSwapClientClient) ListSwaps(ctx context.Context, in *looprpc.ListSwapsRequest, opts ...grpc.CallOption) (*looprpc.ListSwapsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSwaps", varargs...)
	ret0, _ := ret[0].(*looprpc.ListSwapsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSwaps indicates an expected call of ListSwaps.
func (mr *MockSwapClientClientMockRecorder) ListSwaps(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSwaps", reflect.TypeOf((*MockSwapClientClient)(nil).ListSwaps), varargs...)
}

// ListUnspentDeposits mocks base method.
func (m *MockSwapClientClient) ListUnspentDeposits(ctx context.Context, in *looprpc.ListUnspentDepositsRequest, opts ...grpc.CallOption) (*looprpc.ListUnspentDepositsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUnspentDeposits", varargs...)
	ret0, _ := ret[0].(*looprpc.ListUnspentDepositsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListUnspentDeposits indicates an expected call of ListUnspentDeposits.
func (mr *MockSwapClientClientMockRecorder) ListUnspentDeposits(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUnspentDeposits", reflect.TypeOf((*MockSwapClientClient)(nil).ListUnspentDeposits), varargs...)
}

// LoopIn mocks base method.
func (m *MockSwapClientClient) LoopIn(ctx context.Context, in *looprpc.LoopInRequest, opts ...grpc.CallOption) (*looprpc.SwapResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoopIn", varargs...)
	ret0, _ := ret[0].(*looprpc.SwapResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoopIn indicates an expected call of LoopIn.
func (mr *MockSwapClientClientMockRecorder) LoopIn(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoopIn", reflect.TypeOf((*MockSwapClientClient)(nil).LoopIn), varargs...)
}

// LoopOut mocks base method.
func (m *MockSwapClientClient) LoopOut(ctx context.Context, in *looprpc.LoopOutRequest, opts ...grpc.CallOption) (*looprpc.SwapResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoopOut", varargs...)
	ret0, _ := ret[0].(*looprpc.SwapResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoopOut indicates an expected call of LoopOut.
func (mr *MockSwapClientClientMockRecorder) LoopOut(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoopOut", reflect.TypeOf((*MockSwapClientClient)(nil).LoopOut), varargs...)
}

// LoopOutQuote mocks base method.
func (m *MockSwapClientClient) LoopOutQuote(ctx context.Context, in *looprpc.QuoteRequest, opts ...grpc.CallOption) (*looprpc.OutQuoteResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoopOutQuote", varargs...)
	ret0, _ := ret[0].(*looprpc.OutQuoteResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoopOutQuote indicates an expected call of LoopOutQuote.
func (mr *MockSwapClientClientMockRecorder) LoopOutQuote(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoopOutQuote", reflect.TypeOf((*MockSwapClientClient)(nil).LoopOutQuote), varargs...)
}

// LoopOutTerms mocks base method.
func (m *MockSwapClientClient) LoopOutTerms(ctx context.Context, in *looprpc.TermsRequest, opts ...grpc.CallOption) (*looprpc.OutTermsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoopOutTerms", varargs...)
	ret0, _ := ret[0].(*looprpc.OutTermsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoopOutTerms indicates an expected call of LoopOutTerms.
func (mr *MockSwapClientClientMockRecorder) LoopOutTerms(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoopOutTerms", reflect.TypeOf((*MockSwapClientClient)(nil).LoopOutTerms), varargs...)
}

// Monitor mocks base method.
func (m *MockSwapClientClient) Monitor(ctx context.Context, in *looprpc.MonitorRequest, opts ...grpc.CallOption) (looprpc.SwapClient_MonitorClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Monitor", varargs...)
	ret0, _ := ret[0].(looprpc.SwapClient_MonitorClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Monitor indicates an expected call of Monitor.
func (mr *MockSwapClientClientMockRecorder) Monitor(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Monitor", reflect.TypeOf((*MockSwapClientClient)(nil).Monitor), varargs...)
}

// NewStaticAddress mocks base method.
func (m *MockSwapClientClient) NewStaticAddress(ctx context.Context, in *looprpc.NewStaticAddressRequest, opts ...grpc.CallOption) (*looprpc.NewStaticAddressResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewStaticAddress", varargs...)
	ret0, _ := ret[0].(*looprpc.NewStaticAddressResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewStaticAddress indicates an expected call of NewStaticAddress.
func (mr *MockSwapClientClientMockRecorder) NewStaticAddress(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewStaticAddress", reflect.TypeOf((*MockSwapClientClient)(nil).NewStaticAddress), varargs...)
}

// Probe mocks base method.
func (m *MockSwapClientClient) Probe(ctx context.Context, in *looprpc.ProbeRequest, opts ...grpc.CallOption) (*looprpc.ProbeResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Probe", varargs...)
	ret0, _ := ret[0].(*looprpc.ProbeResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Probe indicates an expected call of Probe.
func (mr *MockSwapClientClientMockRecorder) Probe(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Probe", reflect.TypeOf((*MockSwapClientClient)(nil).Probe), varargs...)
}

// SetLiquidityParams mocks base method.
func (m *MockSwapClientClient) SetLiquidityParams(ctx context.Context, in *looprpc.SetLiquidityParamsRequest, opts ...grpc.CallOption) (*looprpc.SetLiquidityParamsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetLiquidityParams", varargs...)
	ret0, _ := ret[0].(*looprpc.SetLiquidityParamsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetLiquidityParams indicates an expected call of SetLiquidityParams.
func (mr *MockSwapClientClientMockRecorder) SetLiquidityParams(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLiquidityParams", reflect.TypeOf((*MockSwapClientClient)(nil).SetLiquidityParams), varargs...)
}

// StaticAddressLoopIn mocks base method.
func (m *MockSwapClientClient) StaticAddressLoopIn(ctx context.Context, in *looprpc.StaticAddressLoopInRequest, opts ...grpc.CallOption) (*looprpc.StaticAddressLoopInResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StaticAddressLoopIn", varargs...)
	ret0, _ := ret[0].(*looprpc.StaticAddressLoopInResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StaticAddressLoopIn indicates an expected call of StaticAddressLoopIn.
func (mr *MockSwapClientClientMockRecorder) StaticAddressLoopIn(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StaticAddressLoopIn", reflect.TypeOf((*MockSwapClientClient)(nil).StaticAddressLoopIn), varargs...)
}

// SuggestSwaps mocks base method.
func (m *MockSwapClientClient) SuggestSwaps(ctx context.Context, in *looprpc.SuggestSwapsRequest, opts ...grpc.CallOption) (*looprpc.SuggestSwapsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SuggestSwaps", varargs...)
	ret0, _ := ret[0].(*looprpc.SuggestSwapsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SuggestSwaps indicates an expected call of SuggestSwaps.
func (mr *MockSwapClientClientMockRecorder) SuggestSwaps(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SuggestSwaps", reflect.TypeOf((*MockSwapClientClient)(nil).SuggestSwaps), varargs...)
}

// SwapInfo mocks base method.
func (m *MockSwapClientClient) SwapInfo(ctx context.Context, in *looprpc.SwapInfoRequest, opts ...grpc.CallOption) (*looprpc.SwapStatus, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SwapInfo", varargs...)
	ret0, _ := ret[0].(*looprpc.SwapStatus)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SwapInfo indicates an expected call of SwapInfo.
func (mr *MockSwapClientClientMockRecorder) SwapInfo(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SwapInfo", reflect.TypeOf((*MockSwapClientClient)(nil).SwapInfo), varargs...)
}

// WithdrawDeposits mocks base method.
func (m *MockSwapClientClient) WithdrawDeposits(ctx context.Context, in *looprpc.WithdrawDepositsRequest, opts ...grpc.CallOption) (*looprpc.WithdrawDepositsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithdrawDeposits", varargs...)
	ret0, _ := ret[0].(*looprpc.WithdrawDepositsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WithdrawDeposits indicates an expected call of WithdrawDeposits.
func (mr *MockSwapClientClientMockRecorder) WithdrawDeposits(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithdrawDeposits", reflect.TypeOf((*MockSwapClientClient)(nil).WithdrawDeposits), varargs...)
}
