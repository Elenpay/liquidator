// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/lightningnetwork/lnd/lnrpc (interfaces: LightningClient)
//
// Generated by this command:
//
//	mockgen -destination ./lightning_rpc_mock.go -package main github.com/lightningnetwork/lnd/lnrpc LightningClient
//

// Package main is a generated GoMock package.
package main

import (
	context "context"
	reflect "reflect"

	lnrpc "github.com/lightningnetwork/lnd/lnrpc"
	gomock "go.uber.org/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockLightningClient is a mock of LightningClient interface.
type MockLightningClient struct {
	ctrl     *gomock.Controller
	recorder *MockLightningClientMockRecorder
	isgomock struct{}
}

// MockLightningClientMockRecorder is the mock recorder for MockLightningClient.
type MockLightningClientMockRecorder struct {
	mock *MockLightningClient
}

// NewMockLightningClient creates a new mock instance.
func NewMockLightningClient(ctrl *gomock.Controller) *MockLightningClient {
	mock := &MockLightningClient{ctrl: ctrl}
	mock.recorder = &MockLightningClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLightningClient) EXPECT() *MockLightningClientMockRecorder {
	return m.recorder
}

// AbandonChannel mocks base method.
func (m *MockLightningClient) AbandonChannel(ctx context.Context, in *lnrpc.AbandonChannelRequest, opts ...grpc.CallOption) (*lnrpc.AbandonChannelResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AbandonChannel", varargs...)
	ret0, _ := ret[0].(*lnrpc.AbandonChannelResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AbandonChannel indicates an expected call of AbandonChannel.
func (mr *MockLightningClientMockRecorder) AbandonChannel(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AbandonChannel", reflect.TypeOf((*MockLightningClient)(nil).AbandonChannel), varargs...)
}

// AddInvoice mocks base method.
func (m *MockLightningClient) AddInvoice(ctx context.Context, in *lnrpc.Invoice, opts ...grpc.CallOption) (*lnrpc.AddInvoiceResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddInvoice", varargs...)
	ret0, _ := ret[0].(*lnrpc.AddInvoiceResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddInvoice indicates an expected call of AddInvoice.
func (mr *MockLightningClientMockRecorder) AddInvoice(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddInvoice", reflect.TypeOf((*MockLightningClient)(nil).AddInvoice), varargs...)
}

// BakeMacaroon mocks base method.
func (m *MockLightningClient) BakeMacaroon(ctx context.Context, in *lnrpc.BakeMacaroonRequest, opts ...grpc.CallOption) (*lnrpc.BakeMacaroonResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BakeMacaroon", varargs...)
	ret0, _ := ret[0].(*lnrpc.BakeMacaroonResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BakeMacaroon indicates an expected call of BakeMacaroon.
func (mr *MockLightningClientMockRecorder) BakeMacaroon(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BakeMacaroon", reflect.TypeOf((*MockLightningClient)(nil).BakeMacaroon), varargs...)
}

// BatchOpenChannel mocks base method.
func (m *MockLightningClient) BatchOpenChannel(ctx context.Context, in *lnrpc.BatchOpenChannelRequest, opts ...grpc.CallOption) (*lnrpc.BatchOpenChannelResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchOpenChannel", varargs...)
	ret0, _ := ret[0].(*lnrpc.BatchOpenChannelResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchOpenChannel indicates an expected call of BatchOpenChannel.
func (mr *MockLightningClientMockRecorder) BatchOpenChannel(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchOpenChannel", reflect.TypeOf((*MockLightningClient)(nil).BatchOpenChannel), varargs...)
}

// ChannelAcceptor mocks base method.
func (m *MockLightningClient) ChannelAcceptor(ctx context.Context, opts ...grpc.CallOption) (lnrpc.Lightning_ChannelAcceptorClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ChannelAcceptor", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_ChannelAcceptorClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ChannelAcceptor indicates an expected call of ChannelAcceptor.
func (mr *MockLightningClientMockRecorder) ChannelAcceptor(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChannelAcceptor", reflect.TypeOf((*MockLightningClient)(nil).ChannelAcceptor), varargs...)
}

// ChannelBalance mocks base method.
func (m *MockLightningClient) ChannelBalance(ctx context.Context, in *lnrpc.ChannelBalanceRequest, opts ...grpc.CallOption) (*lnrpc.ChannelBalanceResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ChannelBalance", varargs...)
	ret0, _ := ret[0].(*lnrpc.ChannelBalanceResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ChannelBalance indicates an expected call of ChannelBalance.
func (mr *MockLightningClientMockRecorder) ChannelBalance(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChannelBalance", reflect.TypeOf((*MockLightningClient)(nil).ChannelBalance), varargs...)
}

// CheckMacaroonPermissions mocks base method.
func (m *MockLightningClient) CheckMacaroonPermissions(ctx context.Context, in *lnrpc.CheckMacPermRequest, opts ...grpc.CallOption) (*lnrpc.CheckMacPermResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CheckMacaroonPermissions", varargs...)
	ret0, _ := ret[0].(*lnrpc.CheckMacPermResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckMacaroonPermissions indicates an expected call of CheckMacaroonPermissions.
func (mr *MockLightningClientMockRecorder) CheckMacaroonPermissions(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckMacaroonPermissions", reflect.TypeOf((*MockLightningClient)(nil).CheckMacaroonPermissions), varargs...)
}

// CloseChannel mocks base method.
func (m *MockLightningClient) CloseChannel(ctx context.Context, in *lnrpc.CloseChannelRequest, opts ...grpc.CallOption) (lnrpc.Lightning_CloseChannelClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CloseChannel", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_CloseChannelClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CloseChannel indicates an expected call of CloseChannel.
func (mr *MockLightningClientMockRecorder) CloseChannel(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseChannel", reflect.TypeOf((*MockLightningClient)(nil).CloseChannel), varargs...)
}

// ClosedChannels mocks base method.
func (m *MockLightningClient) ClosedChannels(ctx context.Context, in *lnrpc.ClosedChannelsRequest, opts ...grpc.CallOption) (*lnrpc.ClosedChannelsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ClosedChannels", varargs...)
	ret0, _ := ret[0].(*lnrpc.ClosedChannelsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ClosedChannels indicates an expected call of ClosedChannels.
func (mr *MockLightningClientMockRecorder) ClosedChannels(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClosedChannels", reflect.TypeOf((*MockLightningClient)(nil).ClosedChannels), varargs...)
}

// ConnectPeer mocks base method.
func (m *MockLightningClient) ConnectPeer(ctx context.Context, in *lnrpc.ConnectPeerRequest, opts ...grpc.CallOption) (*lnrpc.ConnectPeerResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConnectPeer", varargs...)
	ret0, _ := ret[0].(*lnrpc.ConnectPeerResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConnectPeer indicates an expected call of ConnectPeer.
func (mr *MockLightningClientMockRecorder) ConnectPeer(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConnectPeer", reflect.TypeOf((*MockLightningClient)(nil).ConnectPeer), varargs...)
}

// DebugLevel mocks base method.
func (m *MockLightningClient) DebugLevel(ctx context.Context, in *lnrpc.DebugLevelRequest, opts ...grpc.CallOption) (*lnrpc.DebugLevelResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DebugLevel", varargs...)
	ret0, _ := ret[0].(*lnrpc.DebugLevelResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DebugLevel indicates an expected call of DebugLevel.
func (mr *MockLightningClientMockRecorder) DebugLevel(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DebugLevel", reflect.TypeOf((*MockLightningClient)(nil).DebugLevel), varargs...)
}

// DecodePayReq mocks base method.
func (m *MockLightningClient) DecodePayReq(ctx context.Context, in *lnrpc.PayReqString, opts ...grpc.CallOption) (*lnrpc.PayReq, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DecodePayReq", varargs...)
	ret0, _ := ret[0].(*lnrpc.PayReq)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DecodePayReq indicates an expected call of DecodePayReq.
func (mr *MockLightningClientMockRecorder) DecodePayReq(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DecodePayReq", reflect.TypeOf((*MockLightningClient)(nil).DecodePayReq), varargs...)
}

// DeleteAllPayments mocks base method.
func (m *MockLightningClient) DeleteAllPayments(ctx context.Context, in *lnrpc.DeleteAllPaymentsRequest, opts ...grpc.CallOption) (*lnrpc.DeleteAllPaymentsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAllPayments", varargs...)
	ret0, _ := ret[0].(*lnrpc.DeleteAllPaymentsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteAllPayments indicates an expected call of DeleteAllPayments.
func (mr *MockLightningClientMockRecorder) DeleteAllPayments(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAllPayments", reflect.TypeOf((*MockLightningClient)(nil).DeleteAllPayments), varargs...)
}

// DeleteMacaroonID mocks base method.
func (m *MockLightningClient) DeleteMacaroonID(ctx context.Context, in *lnrpc.DeleteMacaroonIDRequest, opts ...grpc.CallOption) (*lnrpc.DeleteMacaroonIDResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteMacaroonID", varargs...)
	ret0, _ := ret[0].(*lnrpc.DeleteMacaroonIDResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteMacaroonID indicates an expected call of DeleteMacaroonID.
func (mr *MockLightningClientMockRecorder) DeleteMacaroonID(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMacaroonID", reflect.TypeOf((*MockLightningClient)(nil).DeleteMacaroonID), varargs...)
}

// DeletePayment mocks base method.
func (m *MockLightningClient) DeletePayment(ctx context.Context, in *lnrpc.DeletePaymentRequest, opts ...grpc.CallOption) (*lnrpc.DeletePaymentResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeletePayment", varargs...)
	ret0, _ := ret[0].(*lnrpc.DeletePaymentResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeletePayment indicates an expected call of DeletePayment.
func (mr *MockLightningClientMockRecorder) DeletePayment(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePayment", reflect.TypeOf((*MockLightningClient)(nil).DeletePayment), varargs...)
}

// DescribeGraph mocks base method.
func (m *MockLightningClient) DescribeGraph(ctx context.Context, in *lnrpc.ChannelGraphRequest, opts ...grpc.CallOption) (*lnrpc.ChannelGraph, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribeGraph", varargs...)
	ret0, _ := ret[0].(*lnrpc.ChannelGraph)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribeGraph indicates an expected call of DescribeGraph.
func (mr *MockLightningClientMockRecorder) DescribeGraph(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeGraph", reflect.TypeOf((*MockLightningClient)(nil).DescribeGraph), varargs...)
}

// DisconnectPeer mocks base method.
func (m *MockLightningClient) DisconnectPeer(ctx context.Context, in *lnrpc.DisconnectPeerRequest, opts ...grpc.CallOption) (*lnrpc.DisconnectPeerResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DisconnectPeer", varargs...)
	ret0, _ := ret[0].(*lnrpc.DisconnectPeerResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DisconnectPeer indicates an expected call of DisconnectPeer.
func (mr *MockLightningClientMockRecorder) DisconnectPeer(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisconnectPeer", reflect.TypeOf((*MockLightningClient)(nil).DisconnectPeer), varargs...)
}

// EstimateFee mocks base method.
func (m *MockLightningClient) EstimateFee(ctx context.Context, in *lnrpc.EstimateFeeRequest, opts ...grpc.CallOption) (*lnrpc.EstimateFeeResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EstimateFee", varargs...)
	ret0, _ := ret[0].(*lnrpc.EstimateFeeResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EstimateFee indicates an expected call of EstimateFee.
func (mr *MockLightningClientMockRecorder) EstimateFee(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EstimateFee", reflect.TypeOf((*MockLightningClient)(nil).EstimateFee), varargs...)
}

// ExportAllChannelBackups mocks base method.
func (m *MockLightningClient) ExportAllChannelBackups(ctx context.Context, in *lnrpc.ChanBackupExportRequest, opts ...grpc.CallOption) (*lnrpc.ChanBackupSnapshot, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExportAllChannelBackups", varargs...)
	ret0, _ := ret[0].(*lnrpc.ChanBackupSnapshot)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExportAllChannelBackups indicates an expected call of ExportAllChannelBackups.
func (mr *MockLightningClientMockRecorder) ExportAllChannelBackups(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExportAllChannelBackups", reflect.TypeOf((*MockLightningClient)(nil).ExportAllChannelBackups), varargs...)
}

// ExportChannelBackup mocks base method.
func (m *MockLightningClient) ExportChannelBackup(ctx context.Context, in *lnrpc.ExportChannelBackupRequest, opts ...grpc.CallOption) (*lnrpc.ChannelBackup, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExportChannelBackup", varargs...)
	ret0, _ := ret[0].(*lnrpc.ChannelBackup)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExportChannelBackup indicates an expected call of ExportChannelBackup.
func (mr *MockLightningClientMockRecorder) ExportChannelBackup(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExportChannelBackup", reflect.TypeOf((*MockLightningClient)(nil).ExportChannelBackup), varargs...)
}

// FeeReport mocks base method.
func (m *MockLightningClient) FeeReport(ctx context.Context, in *lnrpc.FeeReportRequest, opts ...grpc.CallOption) (*lnrpc.FeeReportResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FeeReport", varargs...)
	ret0, _ := ret[0].(*lnrpc.FeeReportResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FeeReport indicates an expected call of FeeReport.
func (mr *MockLightningClientMockRecorder) FeeReport(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FeeReport", reflect.TypeOf((*MockLightningClient)(nil).FeeReport), varargs...)
}

// ForwardingHistory mocks base method.
func (m *MockLightningClient) ForwardingHistory(ctx context.Context, in *lnrpc.ForwardingHistoryRequest, opts ...grpc.CallOption) (*lnrpc.ForwardingHistoryResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ForwardingHistory", varargs...)
	ret0, _ := ret[0].(*lnrpc.ForwardingHistoryResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ForwardingHistory indicates an expected call of ForwardingHistory.
func (mr *MockLightningClientMockRecorder) ForwardingHistory(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForwardingHistory", reflect.TypeOf((*MockLightningClient)(nil).ForwardingHistory), varargs...)
}

// FundingStateStep mocks base method.
func (m *MockLightningClient) FundingStateStep(ctx context.Context, in *lnrpc.FundingTransitionMsg, opts ...grpc.CallOption) (*lnrpc.FundingStateStepResp, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FundingStateStep", varargs...)
	ret0, _ := ret[0].(*lnrpc.FundingStateStepResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FundingStateStep indicates an expected call of FundingStateStep.
func (mr *MockLightningClientMockRecorder) FundingStateStep(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FundingStateStep", reflect.TypeOf((*MockLightningClient)(nil).FundingStateStep), varargs...)
}

// GetChanInfo mocks base method.
func (m *MockLightningClient) GetChanInfo(ctx context.Context, in *lnrpc.ChanInfoRequest, opts ...grpc.CallOption) (*lnrpc.ChannelEdge, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetChanInfo", varargs...)
	ret0, _ := ret[0].(*lnrpc.ChannelEdge)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetChanInfo indicates an expected call of GetChanInfo.
func (mr *MockLightningClientMockRecorder) GetChanInfo(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetChanInfo", reflect.TypeOf((*MockLightningClient)(nil).GetChanInfo), varargs...)
}

// GetDebugInfo mocks base method.
func (m *MockLightningClient) GetDebugInfo(ctx context.Context, in *lnrpc.GetDebugInfoRequest, opts ...grpc.CallOption) (*lnrpc.GetDebugInfoResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDebugInfo", varargs...)
	ret0, _ := ret[0].(*lnrpc.GetDebugInfoResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDebugInfo indicates an expected call of GetDebugInfo.
func (mr *MockLightningClientMockRecorder) GetDebugInfo(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDebugInfo", reflect.TypeOf((*MockLightningClient)(nil).GetDebugInfo), varargs...)
}

// GetInfo mocks base method.
func (m *MockLightningClient) GetInfo(ctx context.Context, in *lnrpc.GetInfoRequest, opts ...grpc.CallOption) (*lnrpc.GetInfoResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetInfo", varargs...)
	ret0, _ := ret[0].(*lnrpc.GetInfoResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetInfo indicates an expected call of GetInfo.
func (mr *MockLightningClientMockRecorder) GetInfo(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInfo", reflect.TypeOf((*MockLightningClient)(nil).GetInfo), varargs...)
}

// GetNetworkInfo mocks base method.
func (m *MockLightningClient) GetNetworkInfo(ctx context.Context, in *lnrpc.NetworkInfoRequest, opts ...grpc.CallOption) (*lnrpc.NetworkInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetNetworkInfo", varargs...)
	ret0, _ := ret[0].(*lnrpc.NetworkInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNetworkInfo indicates an expected call of GetNetworkInfo.
func (mr *MockLightningClientMockRecorder) GetNetworkInfo(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNetworkInfo", reflect.TypeOf((*MockLightningClient)(nil).GetNetworkInfo), varargs...)
}

// GetNodeInfo mocks base method.
func (m *MockLightningClient) GetNodeInfo(ctx context.Context, in *lnrpc.NodeInfoRequest, opts ...grpc.CallOption) (*lnrpc.NodeInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetNodeInfo", varargs...)
	ret0, _ := ret[0].(*lnrpc.NodeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNodeInfo indicates an expected call of GetNodeInfo.
func (mr *MockLightningClientMockRecorder) GetNodeInfo(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNodeInfo", reflect.TypeOf((*MockLightningClient)(nil).GetNodeInfo), varargs...)
}

// GetNodeMetrics mocks base method.
func (m *MockLightningClient) GetNodeMetrics(ctx context.Context, in *lnrpc.NodeMetricsRequest, opts ...grpc.CallOption) (*lnrpc.NodeMetricsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetNodeMetrics", varargs...)
	ret0, _ := ret[0].(*lnrpc.NodeMetricsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNodeMetrics indicates an expected call of GetNodeMetrics.
func (mr *MockLightningClientMockRecorder) GetNodeMetrics(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNodeMetrics", reflect.TypeOf((*MockLightningClient)(nil).GetNodeMetrics), varargs...)
}

// GetRecoveryInfo mocks base method.
func (m *MockLightningClient) GetRecoveryInfo(ctx context.Context, in *lnrpc.GetRecoveryInfoRequest, opts ...grpc.CallOption) (*lnrpc.GetRecoveryInfoResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRecoveryInfo", varargs...)
	ret0, _ := ret[0].(*lnrpc.GetRecoveryInfoResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRecoveryInfo indicates an expected call of GetRecoveryInfo.
func (mr *MockLightningClientMockRecorder) GetRecoveryInfo(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRecoveryInfo", reflect.TypeOf((*MockLightningClient)(nil).GetRecoveryInfo), varargs...)
}

// GetTransactions mocks base method.
func (m *MockLightningClient) GetTransactions(ctx context.Context, in *lnrpc.GetTransactionsRequest, opts ...grpc.CallOption) (*lnrpc.TransactionDetails, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTransactions", varargs...)
	ret0, _ := ret[0].(*lnrpc.TransactionDetails)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactions indicates an expected call of GetTransactions.
func (mr *MockLightningClientMockRecorder) GetTransactions(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactions", reflect.TypeOf((*MockLightningClient)(nil).GetTransactions), varargs...)
}

// ListAliases mocks base method.
func (m *MockLightningClient) ListAliases(ctx context.Context, in *lnrpc.ListAliasesRequest, opts ...grpc.CallOption) (*lnrpc.ListAliasesResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAliases", varargs...)
	ret0, _ := ret[0].(*lnrpc.ListAliasesResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAliases indicates an expected call of ListAliases.
func (mr *MockLightningClientMockRecorder) ListAliases(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAliases", reflect.TypeOf((*MockLightningClient)(nil).ListAliases), varargs...)
}

// ListChannels mocks base method.
func (m *MockLightningClient) ListChannels(ctx context.Context, in *lnrpc.ListChannelsRequest, opts ...grpc.CallOption) (*lnrpc.ListChannelsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListChannels", varargs...)
	ret0, _ := ret[0].(*lnrpc.ListChannelsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListChannels indicates an expected call of ListChannels.
func (mr *MockLightningClientMockRecorder) ListChannels(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListChannels", reflect.TypeOf((*MockLightningClient)(nil).ListChannels), varargs...)
}

// ListInvoices mocks base method.
func (m *MockLightningClient) ListInvoices(ctx context.Context, in *lnrpc.ListInvoiceRequest, opts ...grpc.CallOption) (*lnrpc.ListInvoiceResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListInvoices", varargs...)
	ret0, _ := ret[0].(*lnrpc.ListInvoiceResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListInvoices indicates an expected call of ListInvoices.
func (mr *MockLightningClientMockRecorder) ListInvoices(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListInvoices", reflect.TypeOf((*MockLightningClient)(nil).ListInvoices), varargs...)
}

// ListMacaroonIDs mocks base method.
func (m *MockLightningClient) ListMacaroonIDs(ctx context.Context, in *lnrpc.ListMacaroonIDsRequest, opts ...grpc.CallOption) (*lnrpc.ListMacaroonIDsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMacaroonIDs", varargs...)
	ret0, _ := ret[0].(*lnrpc.ListMacaroonIDsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMacaroonIDs indicates an expected call of ListMacaroonIDs.
func (mr *MockLightningClientMockRecorder) ListMacaroonIDs(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMacaroonIDs", reflect.TypeOf((*MockLightningClient)(nil).ListMacaroonIDs), varargs...)
}

// ListPayments mocks base method.
func (m *MockLightningClient) ListPayments(ctx context.Context, in *lnrpc.ListPaymentsRequest, opts ...grpc.CallOption) (*lnrpc.ListPaymentsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPayments", varargs...)
	ret0, _ := ret[0].(*lnrpc.ListPaymentsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPayments indicates an expected call of ListPayments.
func (mr *MockLightningClientMockRecorder) ListPayments(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPayments", reflect.TypeOf((*MockLightningClient)(nil).ListPayments), varargs...)
}

// ListPeers mocks base method.
func (m *MockLightningClient) ListPeers(ctx context.Context, in *lnrpc.ListPeersRequest, opts ...grpc.CallOption) (*lnrpc.ListPeersResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPeers", varargs...)
	ret0, _ := ret[0].(*lnrpc.ListPeersResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPeers indicates an expected call of ListPeers.
func (mr *MockLightningClientMockRecorder) ListPeers(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPeers", reflect.TypeOf((*MockLightningClient)(nil).ListPeers), varargs...)
}

// ListPermissions mocks base method.
func (m *MockLightningClient) ListPermissions(ctx context.Context, in *lnrpc.ListPermissionsRequest, opts ...grpc.CallOption) (*lnrpc.ListPermissionsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPermissions", varargs...)
	ret0, _ := ret[0].(*lnrpc.ListPermissionsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPermissions indicates an expected call of ListPermissions.
func (mr *MockLightningClientMockRecorder) ListPermissions(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPermissions", reflect.TypeOf((*MockLightningClient)(nil).ListPermissions), varargs...)
}

// ListUnspent mocks base method.
func (m *MockLightningClient) ListUnspent(ctx context.Context, in *lnrpc.ListUnspentRequest, opts ...grpc.CallOption) (*lnrpc.ListUnspentResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUnspent", varargs...)
	ret0, _ := ret[0].(*lnrpc.ListUnspentResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListUnspent indicates an expected call of ListUnspent.
func (mr *MockLightningClientMockRecorder) ListUnspent(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUnspent", reflect.TypeOf((*MockLightningClient)(nil).ListUnspent), varargs...)
}

// LookupHtlcResolution mocks base method.
func (m *MockLightningClient) LookupHtlcResolution(ctx context.Context, in *lnrpc.LookupHtlcResolutionRequest, opts ...grpc.CallOption) (*lnrpc.LookupHtlcResolutionResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LookupHtlcResolution", varargs...)
	ret0, _ := ret[0].(*lnrpc.LookupHtlcResolutionResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LookupHtlcResolution indicates an expected call of LookupHtlcResolution.
func (mr *MockLightningClientMockRecorder) LookupHtlcResolution(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LookupHtlcResolution", reflect.TypeOf((*MockLightningClient)(nil).LookupHtlcResolution), varargs...)
}

// LookupInvoice mocks base method.
func (m *MockLightningClient) LookupInvoice(ctx context.Context, in *lnrpc.PaymentHash, opts ...grpc.CallOption) (*lnrpc.Invoice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LookupInvoice", varargs...)
	ret0, _ := ret[0].(*lnrpc.Invoice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LookupInvoice indicates an expected call of LookupInvoice.
func (mr *MockLightningClientMockRecorder) LookupInvoice(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LookupInvoice", reflect.TypeOf((*MockLightningClient)(nil).LookupInvoice), varargs...)
}

// NewAddress mocks base method.
func (m *MockLightningClient) NewAddress(ctx context.Context, in *lnrpc.NewAddressRequest, opts ...grpc.CallOption) (*lnrpc.NewAddressResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewAddress", varargs...)
	ret0, _ := ret[0].(*lnrpc.NewAddressResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewAddress indicates an expected call of NewAddress.
func (mr *MockLightningClientMockRecorder) NewAddress(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewAddress", reflect.TypeOf((*MockLightningClient)(nil).NewAddress), varargs...)
}

// OpenChannel mocks base method.
func (m *MockLightningClient) OpenChannel(ctx context.Context, in *lnrpc.OpenChannelRequest, opts ...grpc.CallOption) (lnrpc.Lightning_OpenChannelClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OpenChannel", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_OpenChannelClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenChannel indicates an expected call of OpenChannel.
func (mr *MockLightningClientMockRecorder) OpenChannel(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenChannel", reflect.TypeOf((*MockLightningClient)(nil).OpenChannel), varargs...)
}

// OpenChannelSync mocks base method.
func (m *MockLightningClient) OpenChannelSync(ctx context.Context, in *lnrpc.OpenChannelRequest, opts ...grpc.CallOption) (*lnrpc.ChannelPoint, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OpenChannelSync", varargs...)
	ret0, _ := ret[0].(*lnrpc.ChannelPoint)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenChannelSync indicates an expected call of OpenChannelSync.
func (mr *MockLightningClientMockRecorder) OpenChannelSync(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenChannelSync", reflect.TypeOf((*MockLightningClient)(nil).OpenChannelSync), varargs...)
}

// PendingChannels mocks base method.
func (m *MockLightningClient) PendingChannels(ctx context.Context, in *lnrpc.PendingChannelsRequest, opts ...grpc.CallOption) (*lnrpc.PendingChannelsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PendingChannels", varargs...)
	ret0, _ := ret[0].(*lnrpc.PendingChannelsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PendingChannels indicates an expected call of PendingChannels.
func (mr *MockLightningClientMockRecorder) PendingChannels(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PendingChannels", reflect.TypeOf((*MockLightningClient)(nil).PendingChannels), varargs...)
}

// QueryRoutes mocks base method.
func (m *MockLightningClient) QueryRoutes(ctx context.Context, in *lnrpc.QueryRoutesRequest, opts ...grpc.CallOption) (*lnrpc.QueryRoutesResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRoutes", varargs...)
	ret0, _ := ret[0].(*lnrpc.QueryRoutesResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryRoutes indicates an expected call of QueryRoutes.
func (mr *MockLightningClientMockRecorder) QueryRoutes(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRoutes", reflect.TypeOf((*MockLightningClient)(nil).QueryRoutes), varargs...)
}

// RegisterRPCMiddleware mocks base method.
func (m *MockLightningClient) RegisterRPCMiddleware(ctx context.Context, opts ...grpc.CallOption) (lnrpc.Lightning_RegisterRPCMiddlewareClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RegisterRPCMiddleware", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_RegisterRPCMiddlewareClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RegisterRPCMiddleware indicates an expected call of RegisterRPCMiddleware.
func (mr *MockLightningClientMockRecorder) RegisterRPCMiddleware(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterRPCMiddleware", reflect.TypeOf((*MockLightningClient)(nil).RegisterRPCMiddleware), varargs...)
}

// RestoreChannelBackups mocks base method.
func (m *MockLightningClient) RestoreChannelBackups(ctx context.Context, in *lnrpc.RestoreChanBackupRequest, opts ...grpc.CallOption) (*lnrpc.RestoreBackupResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RestoreChannelBackups", varargs...)
	ret0, _ := ret[0].(*lnrpc.RestoreBackupResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RestoreChannelBackups indicates an expected call of RestoreChannelBackups.
func (mr *MockLightningClientMockRecorder) RestoreChannelBackups(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestoreChannelBackups", reflect.TypeOf((*MockLightningClient)(nil).RestoreChannelBackups), varargs...)
}

// SendCoins mocks base method.
func (m *MockLightningClient) SendCoins(ctx context.Context, in *lnrpc.SendCoinsRequest, opts ...grpc.CallOption) (*lnrpc.SendCoinsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SendCoins", varargs...)
	ret0, _ := ret[0].(*lnrpc.SendCoinsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendCoins indicates an expected call of SendCoins.
func (mr *MockLightningClientMockRecorder) SendCoins(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendCoins", reflect.TypeOf((*MockLightningClient)(nil).SendCoins), varargs...)
}

// SendCustomMessage mocks base method.
func (m *MockLightningClient) SendCustomMessage(ctx context.Context, in *lnrpc.SendCustomMessageRequest, opts ...grpc.CallOption) (*lnrpc.SendCustomMessageResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SendCustomMessage", varargs...)
	ret0, _ := ret[0].(*lnrpc.SendCustomMessageResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendCustomMessage indicates an expected call of SendCustomMessage.
func (mr *MockLightningClientMockRecorder) SendCustomMessage(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendCustomMessage", reflect.TypeOf((*MockLightningClient)(nil).SendCustomMessage), varargs...)
}

// SendMany mocks base method.
func (m *MockLightningClient) SendMany(ctx context.Context, in *lnrpc.SendManyRequest, opts ...grpc.CallOption) (*lnrpc.SendManyResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SendMany", varargs...)
	ret0, _ := ret[0].(*lnrpc.SendManyResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendMany indicates an expected call of SendMany.
func (mr *MockLightningClientMockRecorder) SendMany(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMany", reflect.TypeOf((*MockLightningClient)(nil).SendMany), varargs...)
}

// SendPayment mocks base method.
func (m *MockLightningClient) SendPayment(ctx context.Context, opts ...grpc.CallOption) (lnrpc.Lightning_SendPaymentClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SendPayment", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_SendPaymentClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendPayment indicates an expected call of SendPayment.
func (mr *MockLightningClientMockRecorder) SendPayment(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendPayment", reflect.TypeOf((*MockLightningClient)(nil).SendPayment), varargs...)
}

// SendPaymentSync mocks base method.
func (m *MockLightningClient) SendPaymentSync(ctx context.Context, in *lnrpc.SendRequest, opts ...grpc.CallOption) (*lnrpc.SendResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SendPaymentSync", varargs...)
	ret0, _ := ret[0].(*lnrpc.SendResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendPaymentSync indicates an expected call of SendPaymentSync.
func (mr *MockLightningClientMockRecorder) SendPaymentSync(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendPaymentSync", reflect.TypeOf((*MockLightningClient)(nil).SendPaymentSync), varargs...)
}

// SendToRoute mocks base method.
func (m *MockLightningClient) SendToRoute(ctx context.Context, opts ...grpc.CallOption) (lnrpc.Lightning_SendToRouteClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SendToRoute", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_SendToRouteClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendToRoute indicates an expected call of SendToRoute.
func (mr *MockLightningClientMockRecorder) SendToRoute(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendToRoute", reflect.TypeOf((*MockLightningClient)(nil).SendToRoute), varargs...)
}

// SendToRouteSync mocks base method.
func (m *MockLightningClient) SendToRouteSync(ctx context.Context, in *lnrpc.SendToRouteRequest, opts ...grpc.CallOption) (*lnrpc.SendResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SendToRouteSync", varargs...)
	ret0, _ := ret[0].(*lnrpc.SendResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendToRouteSync indicates an expected call of SendToRouteSync.
func (mr *MockLightningClientMockRecorder) SendToRouteSync(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendToRouteSync", reflect.TypeOf((*MockLightningClient)(nil).SendToRouteSync), varargs...)
}

// SignMessage mocks base method.
func (m *MockLightningClient) SignMessage(ctx context.Context, in *lnrpc.SignMessageRequest, opts ...grpc.CallOption) (*lnrpc.SignMessageResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SignMessage", varargs...)
	ret0, _ := ret[0].(*lnrpc.SignMessageResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SignMessage indicates an expected call of SignMessage.
func (mr *MockLightningClientMockRecorder) SignMessage(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignMessage", reflect.TypeOf((*MockLightningClient)(nil).SignMessage), varargs...)
}

// StopDaemon mocks base method.
func (m *MockLightningClient) StopDaemon(ctx context.Context, in *lnrpc.StopRequest, opts ...grpc.CallOption) (*lnrpc.StopResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StopDaemon", varargs...)
	ret0, _ := ret[0].(*lnrpc.StopResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StopDaemon indicates an expected call of StopDaemon.
func (mr *MockLightningClientMockRecorder) StopDaemon(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopDaemon", reflect.TypeOf((*MockLightningClient)(nil).StopDaemon), varargs...)
}

// SubscribeChannelBackups mocks base method.
func (m *MockLightningClient) SubscribeChannelBackups(ctx context.Context, in *lnrpc.ChannelBackupSubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeChannelBackupsClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeChannelBackups", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_SubscribeChannelBackupsClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeChannelBackups indicates an expected call of SubscribeChannelBackups.
func (mr *MockLightningClientMockRecorder) SubscribeChannelBackups(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeChannelBackups", reflect.TypeOf((*MockLightningClient)(nil).SubscribeChannelBackups), varargs...)
}

// SubscribeChannelEvents mocks base method.
func (m *MockLightningClient) SubscribeChannelEvents(ctx context.Context, in *lnrpc.ChannelEventSubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeChannelEventsClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeChannelEvents", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_SubscribeChannelEventsClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeChannelEvents indicates an expected call of SubscribeChannelEvents.
func (mr *MockLightningClientMockRecorder) SubscribeChannelEvents(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeChannelEvents", reflect.TypeOf((*MockLightningClient)(nil).SubscribeChannelEvents), varargs...)
}

// SubscribeChannelGraph mocks base method.
func (m *MockLightningClient) SubscribeChannelGraph(ctx context.Context, in *lnrpc.GraphTopologySubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeChannelGraphClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeChannelGraph", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_SubscribeChannelGraphClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeChannelGraph indicates an expected call of SubscribeChannelGraph.
func (mr *MockLightningClientMockRecorder) SubscribeChannelGraph(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeChannelGraph", reflect.TypeOf((*MockLightningClient)(nil).SubscribeChannelGraph), varargs...)
}

// SubscribeCustomMessages mocks base method.
func (m *MockLightningClient) SubscribeCustomMessages(ctx context.Context, in *lnrpc.SubscribeCustomMessagesRequest, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeCustomMessagesClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeCustomMessages", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_SubscribeCustomMessagesClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeCustomMessages indicates an expected call of SubscribeCustomMessages.
func (mr *MockLightningClientMockRecorder) SubscribeCustomMessages(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeCustomMessages", reflect.TypeOf((*MockLightningClient)(nil).SubscribeCustomMessages), varargs...)
}

// SubscribeInvoices mocks base method.
func (m *MockLightningClient) SubscribeInvoices(ctx context.Context, in *lnrpc.InvoiceSubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeInvoicesClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeInvoices", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_SubscribeInvoicesClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeInvoices indicates an expected call of SubscribeInvoices.
func (mr *MockLightningClientMockRecorder) SubscribeInvoices(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeInvoices", reflect.TypeOf((*MockLightningClient)(nil).SubscribeInvoices), varargs...)
}

// SubscribePeerEvents mocks base method.
func (m *MockLightningClient) SubscribePeerEvents(ctx context.Context, in *lnrpc.PeerEventSubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribePeerEventsClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribePeerEvents", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_SubscribePeerEventsClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribePeerEvents indicates an expected call of SubscribePeerEvents.
func (mr *MockLightningClientMockRecorder) SubscribePeerEvents(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribePeerEvents", reflect.TypeOf((*MockLightningClient)(nil).SubscribePeerEvents), varargs...)
}

// SubscribeTransactions mocks base method.
func (m *MockLightningClient) SubscribeTransactions(ctx context.Context, in *lnrpc.GetTransactionsRequest, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeTransactionsClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeTransactions", varargs...)
	ret0, _ := ret[0].(lnrpc.Lightning_SubscribeTransactionsClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeTransactions indicates an expected call of SubscribeTransactions.
func (mr *MockLightningClientMockRecorder) SubscribeTransactions(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeTransactions", reflect.TypeOf((*MockLightningClient)(nil).SubscribeTransactions), varargs...)
}

// UpdateChannelPolicy mocks base method.
func (m *MockLightningClient) UpdateChannelPolicy(ctx context.Context, in *lnrpc.PolicyUpdateRequest, opts ...grpc.CallOption) (*lnrpc.PolicyUpdateResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateChannelPolicy", varargs...)
	ret0, _ := ret[0].(*lnrpc.PolicyUpdateResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateChannelPolicy indicates an expected call of UpdateChannelPolicy.
func (mr *MockLightningClientMockRecorder) UpdateChannelPolicy(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChannelPolicy", reflect.TypeOf((*MockLightningClient)(nil).UpdateChannelPolicy), varargs...)
}

// VerifyChanBackup mocks base method.
func (m *MockLightningClient) VerifyChanBackup(ctx context.Context, in *lnrpc.ChanBackupSnapshot, opts ...grpc.CallOption) (*lnrpc.VerifyChanBackupResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "VerifyChanBackup", varargs...)
	ret0, _ := ret[0].(*lnrpc.VerifyChanBackupResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// VerifyChanBackup indicates an expected call of VerifyChanBackup.
func (mr *MockLightningClientMockRecorder) VerifyChanBackup(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyChanBackup", reflect.TypeOf((*MockLightningClient)(nil).VerifyChanBackup), varargs...)
}

// VerifyMessage mocks base method.
func (m *MockLightningClient) VerifyMessage(ctx context.Context, in *lnrpc.VerifyMessageRequest, opts ...grpc.CallOption) (*lnrpc.VerifyMessageResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "VerifyMessage", varargs...)
	ret0, _ := ret[0].(*lnrpc.VerifyMessageResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// VerifyMessage indicates an expected call of VerifyMessage.
func (mr *MockLightningClientMockRecorder) VerifyMessage(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyMessage", reflect.TypeOf((*MockLightningClient)(nil).VerifyMessage), varargs...)
}

// WalletBalance mocks base method.
func (m *MockLightningClient) WalletBalance(ctx context.Context, in *lnrpc.WalletBalanceRequest, opts ...grpc.CallOption) (*lnrpc.WalletBalanceResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WalletBalance", varargs...)
	ret0, _ := ret[0].(*lnrpc.WalletBalanceResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WalletBalance indicates an expected call of WalletBalance.
func (mr *MockLightningClientMockRecorder) WalletBalance(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalletBalance", reflect.TypeOf((*MockLightningClient)(nil).WalletBalance), varargs...)
}
